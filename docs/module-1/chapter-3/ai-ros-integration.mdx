---
sidebar_position: 2
title: 'How Python AI Agents Send Commands to ROS 2 Controllers'
keywords: [ros2, python, ai, agent, controller, commands, integration, robotics]
description: 'Detailed explanation of how AI agents written in Python send commands to ROS 2 controllers for robot control'
---

# How Python AI Agents Send Commands to ROS 2 Controllers

## Learning Objectives

After completing this section, you will be able to:
- Understand the different methods for sending commands from AI agents to controllers
- Implement command publishing using ROS 2 topics
- Use ROS 2 services for request/response command execution
- Apply ROS 2 actions for long-running command execution with feedback
- Design appropriate command interfaces for different types of robot control

## Overview of Command Communication Patterns

Python AI agents can send commands to ROS 2 controllers through several communication patterns, each suited for different types of interactions:

### 1. Topic-Based Command Publishing
- **Use case**: Continuous control commands (velocity, joint positions)
- **Pattern**: Publisher-Subscriber
- **Characteristics**: Asynchronous, continuous data flow
- **Example**: Sending velocity commands to a mobile robot base controller

### 2. Service-Based Command Requests
- **Use case**: Discrete actions with immediate response (gripper control, navigation goals)
- **Pattern**: Client-Server Request/Response
- **Characteristics**: Synchronous, with immediate feedback
- **Example**: Requesting a robot to move to a specific location

### 3. Action-Based Command Execution
- **Use case**: Long-running tasks with feedback and status updates
- **Pattern**: Client-Server with feedback loop
- **Characteristics**: Asynchronous with continuous feedback
- **Example**: Navigation with continuous progress updates

## Topic-Based Command Publishing

### Concept
The AI agent publishes commands to a topic that the controller subscribes to. This pattern is ideal for continuous control where the agent sends frequent updates.

### Implementation Example

```python
#!/usr/bin/env python3
"""
AI Agent Command Publisher

This node represents an AI agent that publishes commands to robot controllers.
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from std_msgs.msg import String
from sensor_msgs.msg import JointState
import math


class AICommandPublisher(Node):
    """
    An AI agent that publishes commands to ROS 2 controllers.
    """

    def __init__(self):
        super().__init__('ai_command_publisher')

        # Publisher for velocity commands to base controller
        self.cmd_vel_publisher = self.create_publisher(Twist, '/cmd_vel', 10)

        # Publisher for joint position commands to arm controller
        self.joint_cmd_publisher = self.create_publisher(JointState, '/joint_commands', 10)

        # Publisher for gripper commands
        self.gripper_cmd_publisher = self.create_publisher(String, '/gripper_command', 10)

        # Timer for continuous command publishing
        self.timer = self.create_timer(0.1, self.publish_commands)  # 10 Hz

        # Example state for command generation
        self.command_state = 0
        self.get_logger().info('AI Command Publisher initialized')

    def publish_commands(self):
        """
        Publish commands to various controllers based on AI decisions.
        """
        # Example: Send velocity commands for navigation
        self.publish_velocity_command()

        # Example: Send joint commands for manipulation
        self.publish_joint_commands()

        # Example: Send gripper commands based on object detection
        self.publish_gripper_command()

        self.command_state += 1

    def publish_velocity_command(self):
        """
        Publish velocity commands to the base controller.
        """
        msg = Twist()

        # Example: Simple navigation pattern
        if self.command_state % 100 < 50:
            # Move forward
            msg.linear.x = 0.5  # m/s
            msg.angular.z = 0.0  # rad/s
        else:
            # Turn
            msg.linear.x = 0.0
            msg.angular.z = 0.5  # rad/s

        self.cmd_vel_publisher.publish(msg)
        self.get_logger().info(f'Published velocity: linear.x={msg.linear.x}, angular.z={msg.angular.z}')

    def publish_joint_commands(self):
        """
        Publish joint position commands to the arm controller.
        """
        msg = JointState()
        msg.name = ['joint1', 'joint2', 'joint3']

        # Example: Simple joint trajectory
        joint1_pos = math.sin(self.command_state * 0.1) * 0.5
        joint2_pos = math.cos(self.command_state * 0.1) * 0.3
        joint3_pos = 0.0  # Fixed for this example

        msg.position = [joint1_pos, joint2_pos, joint3_pos]
        msg.header.stamp = self.get_clock().now().to_msg()

        self.joint_cmd_publisher.publish(msg)
        self.get_logger().info(f'Published joint commands: {msg.position}')

    def publish_gripper_command(self):
        """
        Publish gripper commands (open/close).
        """
        msg = String()

        # Example: Open gripper every 200 cycles, close otherwise
        if self.command_state % 200 < 10:
            msg.data = 'open'
        elif self.command_state % 200 < 20:
            msg.data = 'close'
        else:
            msg.data = 'stop'  # No action

        self.gripper_cmd_publisher.publish(msg)
        self.get_logger().info(f'Published gripper command: {msg.data}')


def main(args=None):
    """
    Main function to run the AI command publisher.
    """
    rclpy.init(args=args)
    ai_publisher = AICommandPublisher()

    try:
        rclpy.spin(ai_publisher)
    except KeyboardInterrupt:
        pass
    finally:
        ai_publisher.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Controller Side Implementation

```python
#!/usr/bin/env python3
"""
Robot Controller Node

This node receives commands from AI agents and executes them on the robot.
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from sensor_msgs.msg import JointState
from std_msgs.msg import String


class RobotController(Node):
    """
    A controller that receives commands and executes them on the robot.
    """

    def __init__(self):
        super().__init__('robot_controller')

        # Subscribers for different command types
        self.cmd_vel_subscriber = self.create_subscription(
            Twist, '/cmd_vel', self.cmd_vel_callback, 10)

        self.joint_cmd_subscriber = self.create_subscription(
            JointState, '/joint_commands', self.joint_cmd_callback, 10)

        self.gripper_cmd_subscriber = self.create_subscription(
            String, '/gripper_command', self.gripper_cmd_callback, 10)

        # Robot state (simulated)
        self.current_velocity = Twist()
        self.current_joints = JointState()
        self.gripper_state = 'unknown'

        self.get_logger().info('Robot Controller initialized')

    def cmd_vel_callback(self, msg):
        """
        Handle velocity commands from AI agent.
        """
        # In a real robot, this would send commands to motors
        self.current_velocity = msg
        self.get_logger().info(f'Executing velocity command: linear.x={msg.linear.x}, angular.z={msg.angular.z}')

        # Simulate robot movement
        self.execute_velocity_command(msg)

    def joint_cmd_callback(self, msg):
        """
        Handle joint position commands from AI agent.
        """
        # In a real robot, this would send commands to joint controllers
        self.current_joints = msg
        self.get_logger().info(f'Executing joint commands: {msg.position}')

        # Simulate joint movement
        self.execute_joint_command(msg)

    def gripper_cmd_callback(self, msg):
        """
        Handle gripper commands from AI agent.
        """
        # In a real robot, this would control the gripper
        self.gripper_state = msg.data
        self.get_logger().info(f'Executing gripper command: {msg.data}')

        # Simulate gripper action
        self.execute_gripper_command(msg.data)

    def execute_velocity_command(self, cmd):
        """
        Execute velocity command on the robot (simulated).
        """
        # This would interface with actual robot hardware in a real implementation
        self.get_logger().info(f'Velocity command executed: {cmd.linear.x}, {cmd.angular.z}')

    def execute_joint_command(self, cmd):
        """
        Execute joint command on the robot (simulated).
        """
        # This would interface with actual robot hardware in a real implementation
        self.get_logger().info(f'Joint command executed: {cmd.position}')

    def execute_gripper_command(self, cmd):
        """
        Execute gripper command on the robot (simulated).
        """
        # This would interface with actual robot hardware in a real implementation
        self.get_logger().info(f'Gripper command executed: {cmd}')


def main(args=None):
    """
    Main function to run the robot controller.
    """
    rclpy.init(args=args)
    controller = RobotController()

    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        pass
    finally:
        controller.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Service-Based Command Requests

### Concept
The AI agent calls services provided by controllers to execute specific actions and receive immediate feedback.

### Implementation Example

```python
#!/usr/bin/env python3
"""
AI Agent Service Client

This node represents an AI agent that calls services to execute specific actions.
"""

import rclpy
from rclpy.node import Node
from example_interfaces.srv import Trigger
from geometry_msgs.srv import SetPose


class AIServiceClient(Node):
    """
    An AI agent that calls services to execute specific actions.
    """

    def __init__(self):
        super().__init__('ai_service_client')

        # Client for navigation service
        self.nav_client = self.create_client(Trigger, '/navigate_to_goal')

        # Client for gripper service
        self.gripper_client = self.create_client(Trigger, '/gripper_control')

        # Wait for services to be available
        while not self.nav_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Navigation service not available, waiting...')

        while not self.gripper_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Gripper service not available, waiting...')

        # Timer to periodically call services
        self.timer = self.create_timer(5.0, self.call_services)  # Every 5 seconds
        self.call_count = 0

        self.get_logger().info('AI Service Client initialized')

    def call_services(self):
        """
        Call services to execute specific actions.
        """
        self.call_count += 1

        if self.call_count % 2 == 1:
            # Call navigation service
            self.call_navigation_service()
        else:
            # Call gripper service
            self.call_gripper_service()

    def call_navigation_service(self):
        """
        Call navigation service to move robot to a goal.
        """
        request = Trigger.Request()

        future = self.nav_client.call_async(request)
        future.add_done_callback(self.navigation_response_callback)

        self.get_logger().info('Navigation service called')

    def call_gripper_service(self):
        """
        Call gripper service to control gripper.
        """
        request = Trigger.Request()

        future = self.gripper_client.call_async(request)
        future.add_done_callback(self.gripper_response_callback)

        self.get_logger().info('Gripper service called')

    def navigation_response_callback(self, future):
        """
        Handle navigation service response.
        """
        try:
            response = future.result()
            if response.success:
                self.get_logger().info(f'Navigation successful: {response.message}')
            else:
                self.get_logger().error(f'Navigation failed: {response.message}')
        except Exception as e:
            self.get_logger().error(f'Navigation service call failed: {e}')

    def gripper_response_callback(self, future):
        """
        Handle gripper service response.
        """
        try:
            response = future.result()
            if response.success:
                self.get_logger().info(f'Gripper action successful: {response.message}')
            else:
                self.get_logger().error(f'Gripper action failed: {response.message}')
        except Exception as e:
            self.get_logger().error(f'Gripper service call failed: {e}')


def main(args=None):
    """
    Main function to run the AI service client.
    """
    rclpy.init(args=args)
    ai_client = AIServiceClient()

    try:
        rclpy.spin(ai_client)
    except KeyboardInterrupt:
        pass
    finally:
        ai_client.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Action-Based Command Execution

### Concept
For long-running tasks with feedback, AI agents can use ROS 2 actions which provide continuous feedback during execution.

### Implementation Example

```python
#!/usr/bin/env python3
"""
AI Agent Action Client

This node represents an AI agent that uses actions for long-running tasks.
"""

import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from nav2_msgs.action import NavigateToPose
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import Pose
from geometry_msgs.msg import Point
from geometry_msgs.msg import Quaternion


class AIActionClient(Node):
    """
    An AI agent that uses actions for long-running tasks.
    """

    def __init__(self):
        super().__init__('ai_action_client')

        # Action client for navigation
        self._action_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')

        # Timer to periodically send navigation goals
        self.timer = self.create_timer(10.0, self.send_goal)  # Every 10 seconds
        self.goal_count = 0

        self.get_logger().info('AI Action Client initialized')

    def send_goal(self):
        """
        Send a navigation goal to the action server.
        """
        self.goal_count += 1

        # Wait for action server
        if not self._action_client.wait_for_server(timeout_sec=1.0):
            self.get_logger().error('Action server not available')
            return

        # Create goal
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()

        # Set goal position (example: move in a square pattern)
        positions = [
            (1.0, 0.0),   # Right
            (1.0, 1.0),   # Up
            (0.0, 1.0),   # Left
            (0.0, 0.0),   # Back to start
        ]

        pos = positions[self.goal_count % len(positions)]
        goal_msg.pose.pose.position.x = pos[0]
        goal_msg.pose.pose.position.y = pos[1]
        goal_msg.pose.pose.orientation.w = 1.0  # No rotation

        # Send goal
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback)

        self._send_goal_future.add_done_callback(self.goal_response_callback)

        self.get_logger().info(f'Sent navigation goal to position: {pos}')

    def goal_response_callback(self, future):
        """
        Handle goal response.
        """
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            return

        self.get_logger().info('Goal accepted')

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def feedback_callback(self, feedback_msg):
        """
        Handle feedback during action execution.
        """
        feedback = feedback_msg.feedback
        self.get_logger().info(f'Navigation feedback: {feedback.current_pose}')

    def get_result_callback(self, future):
        """
        Handle action result.
        """
        result = future.result().result
        self.get_logger().info(f'Navigation result: {result}')


def main(args=None):
    """
    Main function to run the AI action client.
    """
    rclpy.init(args=args)
    ai_client = AIActionClient()

    try:
        rclpy.spin(ai_client)
    except KeyboardInterrupt:
        pass
    finally:
        ai_client.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Command Interface Design Principles

### 1. Standardized Message Types
Use standard ROS 2 message types when possible:
- `geometry_msgs/Twist` for velocity commands
- `sensor_msgs/JointState` for joint commands
- `std_msgs/String` for simple commands
- Custom message types for complex command structures

### 2. Appropriate Timing
- High-frequency control: Use topics with appropriate QoS
- Discrete actions: Use services for immediate feedback
- Long-running tasks: Use actions with feedback

### 3. Error Handling
Always implement error handling for command execution:

```python
def publish_command_with_error_handling(self, command):
    """
    Publish command with error handling.
    """
    try:
        # Validate command before publishing
        if not self.validate_command(command):
            self.get_logger().error('Invalid command rejected')
            return False

        # Publish command
        self.command_publisher.publish(command)
        return True

    except Exception as e:
        self.get_logger().error(f'Error publishing command: {e}')
        return False

def validate_command(self, command):
    """
    Validate command before execution.
    """
    # Example validation checks
    if hasattr(command, 'linear') and hasattr(command, 'angular'):
        # Check velocity limits
        if abs(command.linear.x) > 1.0 or abs(command.angular.z) > 1.0:
            return False
    return True
```

### 4. Safety Constraints
Implement safety constraints at the AI level:

```python
def apply_safety_constraints(self, command):
    """
    Apply safety constraints to commands before publishing.
    """
    constrained_cmd = command

    # Limit velocities
    if hasattr(command, 'linear'):
        constrained_cmd.linear.x = max(-0.5, min(0.5, command.linear.x))

    if hasattr(command, 'angular'):
        constrained_cmd.angular.z = max(-0.5, min(0.5, command.angular.z))

    return constrained_cmd
```

## Best Practices for Command Sending

### 1. Use Appropriate QoS Settings
For command topics, consider:
- Reliability: Use RELIABLE for critical commands
- Durability: Use VOLATILE for real-time commands
- History: Use KEEP_LAST with appropriate depth

### 2. Implement Command Smoothing
For smooth robot motion:

```python
def smooth_command(self, new_command, previous_command, alpha=0.1):
    """
    Smoothly transition between commands.
    """
    smoothed_cmd = type(new_command)()

    # Example for Twist messages
    if hasattr(new_command, 'linear'):
        smoothed_cmd.linear.x = alpha * new_command.linear.x + (1 - alpha) * previous_command.linear.x
        smoothed_cmd.linear.y = alpha * new_command.linear.y + (1 - alpha) * previous_command.linear.y
        smoothed_cmd.linear.z = alpha * new_command.linear.z + (1 - alpha) * previous_command.linear.z

    if hasattr(new_command, 'angular'):
        smoothed_cmd.angular.x = alpha * new_command.angular.x + (1 - alpha) * previous_command.angular.x
        smoothed_cmd.angular.y = alpha * new_command.angular.y + (1 - alpha) * previous_command.angular.y
        smoothed_cmd.angular.z = alpha * new_command.angular.z + (1 - alpha) * previous_command.angular.z

    return smoothed_cmd
```

### 3. Monitor Command Execution
Track command execution status:

```python
def monitor_command_execution(self, command_id):
    """
    Monitor command execution and handle timeouts.
    """
    start_time = self.get_clock().now()
    timeout = rclpy.duration.Duration(seconds=5.0)

    while (self.get_clock().now() - start_time) < timeout:
        if self.is_command_executed(command_id):
            return True
        rclpy.spin_once(self, timeout_sec=0.1)

    self.get_logger().warn(f'Command {command_id} timed out')
    return False
```

## Summary

Python AI agents can send commands to ROS 2 controllers using three main patterns:

1. **Topic-based publishing**: Best for continuous control commands with high frequency
2. **Service-based requests**: Best for discrete actions requiring immediate feedback
3. **Action-based execution**: Best for long-running tasks with ongoing feedback

When implementing command sending, consider timing requirements, safety constraints, error handling, and appropriate message types. The choice of communication pattern should match the specific requirements of the robot control task.

### Cross-References to Related Sections

For deeper understanding of related concepts, see:
- [Introduction to Python Agent to ROS 2 Controller Bridge](./intro) - Overview of AI-ROS integration
- [How Python AI Agents Receive Sensor Data](./message-passing) - Receiving feedback from controllers
- [ROS 2 Architecture Understanding](../chapter-1/intro) - Communication patterns foundation
- [Python ROS 2 Node Creation](../chapter-2/intro) - Node implementation basics