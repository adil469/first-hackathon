---
sidebar_position: 5
title: 'Code Examples: Message Passing Patterns'
keywords: [ros2, python, ai, agent, controller, message-passing, patterns, examples, communication]
description: 'Code examples demonstrating various message passing patterns between Python AI agents and ROS 2 controllers'
---

# Code Examples: Message Passing Patterns

## Overview

This section provides comprehensive code examples that demonstrate various message passing patterns between Python AI agents and ROS 2 controllers. These examples illustrate the practical implementation of communication patterns discussed in previous sections.

## Pattern 1: Topic-Based Message Passing

### Concept
Topic-based communication enables continuous, asynchronous data flow between AI agents and controllers. This pattern is ideal for real-time control and sensor feedback.

### Publisher Example: AI Agent Command Publisher

```python
#!/usr/bin/env python3
"""
AI Agent Command Publisher

This node demonstrates how an AI agent can publish commands to various controllers
using ROS 2 topics with different Quality of Service (QoS) settings.
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy

from geometry_msgs.msg import Twist
from sensor_msgs.msg import JointState
from std_msgs.msg import String, Float64MultiArray
from builtin_interfaces.msg import Time

import math
import time
from enum import Enum


class CommandPriority(Enum):
    """
    Command priority levels for QoS configuration.
    """
    LOW = 1      # Best effort, low frequency
    MEDIUM = 2   # Reliable, medium frequency
    HIGH = 3     # Reliable, high frequency, keep last


class AICommandPublisher(Node):
    """
    An AI agent that publishes commands to various ROS 2 controllers.
    Demonstrates different QoS configurations for different command types.
    """

    def __init__(self):
        super().__init__('ai_command_publisher')

        # Create QoS profiles for different command priorities
        self.qos_low = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            durability=DurabilityPolicy.VOLATILE,
            history=HistoryPolicy.KEEP_LAST,
            depth=5
        )

        self.qos_medium = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
            history=HistoryPolicy.KEEP_LAST,
            depth=10
        )

        self.qos_high = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
            history=HistoryPolicy.KEEP_LAST,
            depth=20
        )

        # Publishers for different command types with appropriate QoS
        self.cmd_vel_publisher = self.create_publisher(
            Twist, '/cmd_vel', self.qos_medium)
        self.joint_cmd_publisher = self.create_publisher(
            JointState, '/joint_commands', self.qos_medium)
        self.gripper_cmd_publisher = self.create_publisher(
            String, '/gripper_command', self.qos_high)
        self.emergency_stop_publisher = self.create_publisher(
            String, '/emergency_stop', self.qos_high)
        self.debug_publisher = self.create_publisher(
            String, '/ai_debug_info', self.qos_low)

        # Timer for continuous command publishing
        self.timer = self.create_timer(0.1, self.publish_commands)  # 10 Hz

        # State variables for command generation
        self.command_state = 0
        self.robot_mode = 'normal'  # 'normal', 'emergency', 'maintenance'
        self.target_positions = [0.0, 0.0, 0.0]  # Joint positions

        self.get_logger().info('AI Command Publisher initialized')

    def publish_commands(self):
        """
        Publish commands to various controllers based on AI decisions.
        """
        if self.robot_mode == 'emergency':
            self.publish_emergency_stop()
            return

        # Publish velocity commands for navigation
        self.publish_velocity_command()

        # Publish joint commands for manipulation
        self.publish_joint_commands()

        # Publish gripper commands based on task
        self.publish_gripper_command()

        # Publish debug information
        self.publish_debug_info()

        self.command_state += 1

    def publish_velocity_command(self):
        """
        Publish velocity commands to the base controller with safety checks.
        """
        msg = Twist()

        # Example: Generate a velocity command based on current state
        # This could be replaced with actual AI decision logic
        if self.command_state % 100 < 50:
            # Move forward with obstacle avoidance
            msg.linear.x = 0.3  # m/s
            msg.angular.z = self.avoid_obstacles()  # rad/s
        else:
            # Turn in place
            msg.linear.x = 0.0
            msg.angular.z = 0.4  # rad/s

        # Safety checks before publishing
        if self.is_safe_velocity_command(msg):
            self.cmd_vel_publisher.publish(msg)
            self.get_logger().debug(f'Published velocity: linear.x={msg.linear.x:.2f}, angular.z={msg.angular.z:.2f}')
        else:
            self.get_logger().warn('Unsafe velocity command prevented')

    def avoid_obstacles(self):
        """
        Simple obstacle avoidance logic (placeholder).
        In practice, this would use sensor data.
        """
        # This would typically use laser scan or other sensor data
        # to determine if obstacles are present and adjust angular velocity
        return 0.0  # No adjustment for this example

    def is_safe_velocity_command(self, cmd):
        """
        Check if a velocity command is safe to execute.
        """
        # Safety limits
        max_linear = 1.0  # m/s
        max_angular = 1.0  # rad/s

        return (abs(cmd.linear.x) <= max_linear and
                abs(cmd.linear.y) <= max_linear and
                abs(cmd.linear.z) <= max_linear and
                abs(cmd.angular.x) <= max_angular and
                abs(cmd.angular.y) <= max_angular and
                abs(cmd.angular.z) <= max_angular)

    def publish_joint_commands(self):
        """
        Publish joint position commands to the arm controller.
        """
        msg = JointState()
        msg.name = ['joint1', 'joint2', 'joint3', 'joint4']

        # Calculate target positions based on current state
        # This could be based on AI planning algorithms
        t = self.command_state * 0.1  # Time parameter for trajectory

        # Example: Simple periodic joint trajectory
        positions = [
            math.sin(t) * 0.5,      # Joint 1: oscillating
            math.cos(t) * 0.3,      # Joint 2: oscillating
            math.sin(t * 0.5) * 0.2, # Joint 3: slower oscillation
            0.0                     # Joint 4: fixed
        ]

        msg.position = positions
        msg.header.stamp = self.get_clock().now().to_msg()

        # Publish with safety checks
        if self.is_safe_joint_command(msg):
            self.joint_cmd_publisher.publish(msg)
            self.get_logger().debug(f'Published joint commands: {positions}')
        else:
            self.get_logger().warn('Unsafe joint command prevented')

    def is_safe_joint_command(self, cmd):
        """
        Check if a joint command is safe to execute.
        """
        # Check for reasonable joint limits
        joint_limits = {
            'joint1': (-1.57, 1.57),  # -90° to 90°
            'joint2': (-1.0, 1.0),    # -57° to 57°
            'joint3': (-0.5, 0.5),    # -29° to 29°
            'joint4': (-3.14, 3.14)   # -180° to 180°
        }

        for i, pos in enumerate(cmd.position):
            joint_name = cmd.name[i] if i < len(cmd.name) else f'joint{i}'
            if joint_name in joint_limits:
                min_limit, max_limit = joint_limits[joint_name]
                if not (min_limit <= pos <= max_limit):
                    return False

        return True

    def publish_gripper_command(self):
        """
        Publish gripper commands (open/close).
        """
        msg = String()

        # Example: Open gripper every 200 cycles, close otherwise
        cycle = self.command_state % 200
        if cycle < 10:
            msg.data = 'open'
        elif cycle < 20:
            msg.data = 'close'
        else:
            msg.data = 'stop'  # No action

        self.gripper_cmd_publisher.publish(msg)
        self.get_logger().debug(f'Published gripper command: {msg.data}')

    def publish_emergency_stop(self):
        """
        Publish emergency stop command.
        """
        msg = String()
        msg.data = 'EMERGENCY_STOP'
        self.emergency_stop_publisher.publish(msg)
        self.get_logger().warn('Emergency stop published')

    def publish_debug_info(self):
        """
        Publish debug information for monitoring.
        """
        msg = String()
        debug_info = {
            'state': self.command_state,
            'mode': self.robot_mode,
            'time': self.get_clock().now().nanoseconds
        }
        msg.data = str(debug_info)
        self.debug_publisher.publish(msg)

    def set_robot_mode(self, mode):
        """
        Set the robot operating mode.
        """
        if mode in ['normal', 'emergency', 'maintenance']:
            self.robot_mode = mode
            self.get_logger().info(f'Robot mode set to: {mode}')
        else:
            self.get_logger().error(f'Invalid robot mode: {mode}')


def main(args=None):
    """
    Main function to run the AI command publisher.
    """
    rclpy.init(args=args)
    ai_publisher = AICommandPublisher()

    try:
        rclpy.spin(ai_publisher)
    except KeyboardInterrupt:
        pass
    finally:
        ai_publisher.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Subscriber Example: Controller Command Receiver

```python
#!/usr/bin/env python3
"""
Controller Command Receiver

This node demonstrates how a controller receives commands from AI agents
and executes them with safety checks.
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy

from geometry_msgs.msg import Twist
from sensor_msgs.msg import JointState
from std_msgs.msg import String
from builtin_interfaces.msg import Time

import time
from threading import Lock


class RobotController(Node):
    """
    A controller that receives commands from AI agents and executes them safely.
    """

    def __init__(self):
        super().__init__('robot_controller')

        # QoS profile for receiving commands
        self.qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
            history=HistoryPolicy.KEEP_LAST,
            depth=10
        )

        # Subscribers for different command types
        self.cmd_vel_subscriber = self.create_subscription(
            Twist, '/cmd_vel', self.cmd_vel_callback, self.qos_profile)

        self.joint_cmd_subscriber = self.create_subscription(
            JointState, '/joint_commands', self.joint_cmd_callback, self.qos_profile)

        self.gripper_cmd_subscriber = self.create_subscription(
            String, '/gripper_command', self.gripper_cmd_callback, self.qos_profile)

        self.emergency_stop_subscriber = self.create_subscription(
            String, '/emergency_stop', self.emergency_stop_callback, self.qos_profile)

        # Robot state (simulated)
        self.current_velocity = Twist()
        self.current_joints = JointState()
        self.gripper_state = 'unknown'
        self.emergency_active = False

        # Safety parameters
        self.max_velocity = 1.0  # m/s
        self.max_angular = 1.0   # rad/s
        self.safety_lock = Lock()

        # Initialize joint state
        self.current_joints.name = ['joint1', 'joint2', 'joint3', 'joint4']
        self.current_joints.position = [0.0, 0.0, 0.0, 0.0]

        self.get_logger().info('Robot Controller initialized')

    def cmd_vel_callback(self, msg):
        """
        Handle velocity commands from AI agent with safety checks.
        """
        with self.safety_lock:
            if not self.emergency_active:
                # Validate command before execution
                if self.is_safe_velocity_command(msg):
                    self.current_velocity = msg
                    self.execute_velocity_command(msg)
                    self.get_logger().debug(f'Executed velocity command: linear.x={msg.linear.x:.2f}, angular.z={msg.angular.z:.2f}')
                else:
                    self.get_logger().warn(f'Unsafe velocity command rejected: linear.x={msg.linear.x:.2f}, angular.z={msg.angular.z:.2f}')
            else:
                self.get_logger().info('Velocity command ignored due to emergency state')

    def joint_cmd_callback(self, msg):
        """
        Handle joint position commands from AI agent with safety checks.
        """
        with self.safety_lock:
            if not self.emergency_active:
                # Validate command before execution
                if self.is_safe_joint_command(msg):
                    self.current_joints = msg
                    self.execute_joint_command(msg)
                    self.get_logger().debug(f'Executed joint commands: {msg.position}')
                else:
                    self.get_logger().warn(f'Unsafe joint command rejected: {msg.position}')
            else:
                self.get_logger().info('Joint command ignored due to emergency state')

    def gripper_cmd_callback(self, msg):
        """
        Handle gripper commands from AI agent.
        """
        with self.safety_lock:
            if not self.emergency_active:
                # Validate gripper command
                if self.is_valid_gripper_command(msg.data):
                    self.gripper_state = msg.data
                    self.execute_gripper_command(msg.data)
                    self.get_logger().debug(f'Executed gripper command: {msg.data}')
                else:
                    self.get_logger().warn(f'Invalid gripper command: {msg.data}')
            else:
                self.get_logger().info('Gripper command ignored due to emergency state')

    def emergency_stop_callback(self, msg):
        """
        Handle emergency stop commands.
        """
        with self.safety_lock:
            if msg.data == 'EMERGENCY_STOP':
                self.emergency_active = True
                self.get_logger().error('EMERGENCY STOP ACTIVATED')
                # Stop all movement
                self.stop_all_motors()
            else:
                self.emergency_active = False
                self.get_logger().info('Emergency state cleared')

    def is_safe_velocity_command(self, cmd):
        """
        Check if velocity command is safe to execute.
        """
        return (abs(cmd.linear.x) <= self.max_velocity and
                abs(cmd.linear.y) <= self.max_velocity and
                abs(cmd.linear.z) <= self.max_velocity and
                abs(cmd.angular.x) <= self.max_angular and
                abs(cmd.angular.y) <= self.max_angular and
                abs(cmd.angular.z) <= self.max_angular)

    def is_safe_joint_command(self, cmd):
        """
        Check if joint command is safe to execute.
        """
        # Check for reasonable joint limits
        joint_limits = {
            'joint1': (-1.57, 1.57),  # -90° to 90°
            'joint2': (-1.0, 1.0),    # -57° to 57°
            'joint3': (-0.5, 0.5),    # -29° to 29°
            'joint4': (-3.14, 3.14)   # -180° to 180°
        }

        for i, pos in enumerate(cmd.position):
            if i < len(cmd.name):
                joint_name = cmd.name[i]
                if joint_name in joint_limits:
                    min_limit, max_limit = joint_limits[joint_name]
                    if not (min_limit <= pos <= max_limit):
                        return False

        return True

    def is_valid_gripper_command(self, cmd_str):
        """
        Check if gripper command is valid.
        """
        return cmd_str in ['open', 'close', 'stop']

    def execute_velocity_command(self, cmd):
        """
        Execute velocity command on the robot (simulated).
        In a real implementation, this would interface with actual robot hardware.
        """
        # Simulate motor execution
        self.get_logger().debug(f'Velocity command executed: linear.x={cmd.linear.x:.2f}, angular.z={cmd.angular.z:.2f}')
        # In real robot: send commands to motor controllers

    def execute_joint_command(self, cmd):
        """
        Execute joint command on the robot (simulated).
        In a real implementation, this would interface with actual robot hardware.
        """
        # Simulate joint execution
        self.get_logger().debug(f'Joint command executed: {cmd.position}')
        # In real robot: send commands to joint controllers

    def execute_gripper_command(self, cmd):
        """
        Execute gripper command on the robot (simulated).
        In a real implementation, this would interface with actual robot hardware.
        """
        # Simulate gripper execution
        self.get_logger().debug(f'Gripper command executed: {cmd}')
        # In real robot: send command to gripper controller

    def stop_all_motors(self):
        """
        Stop all robot motors immediately.
        """
        stop_cmd = Twist()
        self.current_velocity = stop_cmd
        self.execute_velocity_command(stop_cmd)

        # Reset joint positions to safe state if needed
        self.get_logger().info('All motors stopped')


def main(args=None):
    """
    Main function to run the robot controller.
    """
    rclpy.init(args=args)
    controller = RobotController()

    try:
        rclpy.spin(controller)
    except KeyboardInterrupt:
        pass
    finally:
        controller.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Pattern 2: Service-Based Message Passing

### Service Server Example: AI Decision Service

```python
#!/usr/bin/env python3
"""
AI Decision Service Server

This node provides services that AI agents can call to make decisions
or execute specific actions through the robot.
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy

from example_interfaces.srv import Trigger, SetBool, AddTwoInts
from std_msgs.msg import String
from geometry_msgs.msg import Pose, Point
from sensor_msgs.msg import LaserScan

import time
import random
from threading import Lock


class AIDecisionService(Node):
    """
    A service server that provides AI decision-making capabilities to other nodes.
    """

    def __init__(self):
        super().__init__('ai_decision_service')

        # QoS profile for service communication
        self.qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            depth=10
        )

        # Service servers
        self.navigate_service = self.create_service(
            Trigger, '/ai/navigate_to_goal', self.navigate_to_goal_callback)

        self.grasp_object_service = self.create_service(
            Trigger, '/ai/grasp_object', self.grasp_object_callback)

        self.analyze_environment_service = self.create_service(
            Trigger, '/ai/analyze_environment', self.analyze_environment_callback)

        self.set_behavior_service = self.create_service(
            SetBool, '/ai/set_behavior_mode', self.set_behavior_mode_callback)

        self.calculate_path_service = self.create_service(
            AddTwoInts, '/ai/calculate_path_cost', self.calculate_path_cost_callback)

        # Subscribers for sensor data
        self.laser_subscriber = self.create_subscription(
            LaserScan, '/scan', self.laser_callback, self.qos_profile)

        # Internal state
        self.behavior_mode = 'autonomous'  # 'autonomous', 'manual', 'disabled'
        self.laser_data = None
        self.service_lock = Lock()

        self.get_logger().info('AI Decision Service initialized')

    def navigate_to_goal_callback(self, request, response):
        """
        Handle navigation goal requests.
        """
        with self.service_lock:
            self.get_logger().info('Received navigation request')

            # Check if robot is in appropriate mode
            if self.behavior_mode != 'autonomous':
                response.success = False
                response.message = f'Navigation disabled in {self.behavior_mode} mode'
                return response

            # Check for obstacles using laser data
            if self.laser_data and self.has_obstacles_ahead():
                response.success = False
                response.message = 'Path blocked by obstacles'
                return response

            # Simulate navigation planning and execution
            success = self.simulate_navigation_planning()

            if success:
                response.success = True
                response.message = 'Navigation goal accepted and being executed'
                self.get_logger().info('Navigation goal accepted')
            else:
                response.success = False
                response.message = 'Failed to find valid navigation path'
                self.get_logger().warn('Navigation goal rejected')

            return response

    def grasp_object_callback(self, request, response):
        """
        Handle object grasping requests.
        """
        with self.service_lock:
            self.get_logger().info('Received grasp object request')

            # Check if robot is in appropriate mode
            if self.behavior_mode != 'autonomous':
                response.success = False
                response.message = f'Grasping disabled in {self.behavior_mode} mode'
                return response

            # Simulate object detection and grasp planning
            success, grasp_pose = self.simulate_grasp_planning()

            if success:
                response.success = True
                response.message = f'Object grasp planned at {grasp_pose}'
                self.get_logger().info(f'Grasp planned at {grasp_pose}')
            else:
                response.success = False
                response.message = 'No suitable grasp pose found'
                self.get_logger().warn('Grasp planning failed')

            return response

    def analyze_environment_callback(self, request, response):
        """
        Handle environment analysis requests.
        """
        with self.service_lock:
            self.get_logger().info('Received environment analysis request')

            # Analyze current environment
            environment_data = self.analyze_current_environment()

            response.success = True
            response.message = f'Environment analysis complete: {environment_data}'
            self.get_logger().info(f'Environment analysis: {environment_data}')

            return response

    def set_behavior_mode_callback(self, request, response):
        """
        Handle behavior mode change requests.
        """
        with self.service_lock:
            new_mode = 'autonomous' if request.data else 'manual'

            old_mode = self.behavior_mode
            self.behavior_mode = new_mode

            response.success = True
            response.message = f'Behavior mode changed from {old_mode} to {new_mode}'
            self.get_logger().info(f'Behavior mode changed to: {new_mode}')

            return response

    def calculate_path_cost_callback(self, request, response):
        """
        Handle path cost calculation requests.
        """
        with self.service_lock:
            self.get_logger().info(f'Received path cost calculation: {request.a} to {request.b}')

            # Simulate path cost calculation
            # In practice, this would use actual path planning algorithms
            cost = abs(request.a - request.b) * random.uniform(0.8, 1.2)

            response.sum = int(cost)
            self.get_logger().info(f'Calculated path cost: {response.sum}')

            return response

    def laser_callback(self, msg):
        """
        Handle laser scan data for obstacle detection.
        """
        self.laser_data = msg

    def has_obstacles_ahead(self):
        """
        Check if there are obstacles in front of the robot.
        """
        if not self.laser_data:
            return False

        # Check the front 30 degrees of the laser scan
        front_ranges = self.laser_data.ranges[:len(self.laser_data.ranges)//12] + \
                       self.laser_data.ranges[-len(self.laser_data.ranges)//12:]

        # Check for obstacles within 1 meter
        for range_val in front_ranges:
            if 0.1 < range_val < 1.0:  # Between 10cm and 1m
                return True

        return False

    def simulate_navigation_planning(self):
        """
        Simulate navigation planning (placeholder for actual AI planning).
        """
        # Simulate planning time
        time.sleep(0.1)

        # Simulate success/failure
        return random.choice([True, True, True, False])  # 75% success rate

    def simulate_grasp_planning(self):
        """
        Simulate grasp planning (placeholder for actual AI planning).
        """
        # Simulate planning time
        time.sleep(0.2)

        # Simulate success/failure
        if random.choice([True, False]):
            grasp_pose = Point(x=1.0, y=0.5, z=0.1)
            return True, grasp_pose
        else:
            return False, None

    def analyze_current_environment(self):
        """
        Analyze current environment using sensor data.
        """
        obstacles = 0
        if self.laser_data:
            obstacles = sum(1 for r in self.laser_data.ranges if 0.1 < r < 2.0)

        environment_data = {
            'obstacles_nearby': obstacles,
            'behavior_mode': self.behavior_mode,
            'timestamp': self.get_clock().now().nanoseconds
        }

        return environment_data


def main(args=None):
    """
    Main function to run the AI decision service.
    """
    rclpy.init(args=args)
    ai_service = AIDecisionService()

    try:
        rclpy.spin(ai_service)
    except KeyboardInterrupt:
        pass
    finally:
        ai_service.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Service Client Example: AI Service User

```python
#!/usr/bin/env python3
"""
AI Service Client

This node demonstrates how an AI agent can call services provided by controllers.
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy

from example_interfaces.srv import Trigger, SetBool, AddTwoInts
from std_msgs.msg import String

import time


class AIServiceClient(Node):
    """
    An AI agent that calls services to execute specific actions.
    """

    def __init__(self):
        super().__init__('ai_service_client')

        # QoS profile for service communication
        self.qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            depth=10
        )

        # Service clients
        self.navigate_client = self.create_client(Trigger, '/ai/navigate_to_goal')
        self.grasp_client = self.create_client(Trigger, '/ai/grasp_object')
        self.analyze_client = self.create_client(Trigger, '/ai/analyze_environment')
        self.behavior_client = self.create_client(SetBool, '/ai/set_behavior_mode')
        self.path_cost_client = self.create_client(AddTwoInts, '/ai/calculate_path_cost')

        # Publisher for status updates
        self.status_publisher = self.create_publisher(String, '/ai_service_status', self.qos_profile)

        # Timer to periodically call services
        self.timer = self.create_timer(3.0, self.periodic_service_calls)  # Every 3 seconds
        self.call_count = 0

        # Wait for services to be available
        self.wait_for_services()

        self.get_logger().info('AI Service Client initialized')

    def wait_for_services(self):
        """
        Wait for all services to be available.
        """
        services = [
            (self.navigate_client, 'navigate_to_goal'),
            (self.grasp_client, 'grasp_object'),
            (self.analyze_client, 'analyze_environment'),
            (self.behavior_client, 'set_behavior_mode'),
            (self.path_cost_client, 'calculate_path_cost')
        ]

        for client, name in services:
            while not client.wait_for_service(timeout_sec=1.0):
                self.get_logger().info(f'{name} service not available, waiting...')

        self.get_logger().info('All services available')

    def periodic_service_calls(self):
        """
        Periodically call different services based on call count.
        """
        self.call_count += 1

        if self.call_count % 5 == 1:
            # Call navigation service
            self.call_navigation_service()
        elif self.call_count % 5 == 2:
            # Call grasp service
            self.call_grasp_service()
        elif self.call_count % 5 == 3:
            # Call environment analysis
            self.call_analyze_service()
        elif self.call_count % 5 == 4:
            # Toggle behavior mode
            self.call_behavior_service()
        else:
            # Calculate path cost
            self.call_path_cost_service()

    def call_navigation_service(self):
        """
        Call navigation service to move robot to a goal.
        """
        request = Trigger.Request()

        future = self.navigate_client.call_async(request)
        future.add_done_callback(self.navigation_response_callback)

        self.get_logger().info('Navigation service called')

    def call_grasp_service(self):
        """
        Call grasp service to grasp an object.
        """
        request = Trigger.Request()

        future = self.grasp_client.call_async(request)
        future.add_done_callback(self.grasp_response_callback)

        self.get_logger().info('Grasp service called')

    def call_analyze_service(self):
        """
        Call environment analysis service.
        """
        request = Trigger.Request()

        future = self.analyze_client.call_async(request)
        future.add_done_callback(self.analyze_response_callback)

        self.get_logger().info('Environment analysis service called')

    def call_behavior_service(self):
        """
        Call behavior mode service to toggle autonomous/manual.
        """
        request = SetBool.Request()
        request.data = (self.call_count // 5) % 2 == 0  # Toggle every 5 calls

        future = self.behavior_client.call_async(request)
        future.add_done_callback(self.behavior_response_callback)

        self.get_logger().info(f'Behavior mode service called with data: {request.data}')

    def call_path_cost_service(self):
        """
        Call path cost calculation service.
        """
        request = AddTwoInts.Request()
        request.a = (self.call_count * 2) % 10
        request.b = (self.call_count * 3) % 10

        future = self.path_cost_client.call_async(request)
        future.add_done_callback(self.path_cost_response_callback)

        self.get_logger().info(f'Path cost service called with {request.a} and {request.b}')

    def navigation_response_callback(self, future):
        """
        Handle navigation service response.
        """
        try:
            response = future.result()
            if response.success:
                self.get_logger().info(f'Navigation successful: {response.message}')
            else:
                self.get_logger().error(f'Navigation failed: {response.message}')

            # Publish status update
            status_msg = String()
            status_msg.data = f'Navigation: {response.message}'
            self.status_publisher.publish(status_msg)

        except Exception as e:
            self.get_logger().error(f'Navigation service call failed: {e}')

    def grasp_response_callback(self, future):
        """
        Handle grasp service response.
        """
        try:
            response = future.result()
            if response.success:
                self.get_logger().info(f'Grasp successful: {response.message}')
            else:
                self.get_logger().error(f'Grasp failed: {response.message}')

            # Publish status update
            status_msg = String()
            status_msg.data = f'Grasp: {response.message}'
            self.status_publisher.publish(status_msg)

        except Exception as e:
            self.get_logger().error(f'Grasp service call failed: {e}')

    def analyze_response_callback(self, future):
        """
        Handle environment analysis service response.
        """
        try:
            response = future.result()
            if response.success:
                self.get_logger().info(f'Analysis successful: {response.message}')
            else:
                self.get_logger().error(f'Analysis failed: {response.message}')

            # Publish status update
            status_msg = String()
            status_msg.data = f'Analysis: {response.message}'
            self.status_publisher.publish(status_msg)

        except Exception as e:
            self.get_logger().error(f'Analysis service call failed: {e}')

    def behavior_response_callback(self, future):
        """
        Handle behavior mode service response.
        """
        try:
            response = future.result()
            if response.success:
                self.get_logger().info(f'Behavior mode: {response.message}')
            else:
                self.get_logger().error(f'Behavior mode failed: {response.message}')

            # Publish status update
            status_msg = String()
            status_msg.data = f'Behavior: {response.message}'
            self.status_publisher.publish(status_msg)

        except Exception as e:
            self.get_logger().error(f'Behavior service call failed: {e}')

    def path_cost_response_callback(self, future):
        """
        Handle path cost service response.
        """
        try:
            response = future.result()
            self.get_logger().info(f'Path cost calculated: {response.sum}')

            # Publish status update
            status_msg = String()
            status_msg.data = f'Path cost: {response.sum}'
            self.status_publisher.publish(status_msg)

        except Exception as e:
            self.get_logger().error(f'Path cost service call failed: {e}')


def main(args=None):
    """
    Main function to run the AI service client.
    """
    rclpy.init(args=args)
    ai_client = AIServiceClient()

    try:
        rclpy.spin(ai_client)
    except KeyboardInterrupt:
        pass
    finally:
        ai_client.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Pattern 3: Action-Based Message Passing

### Action Server Example: Navigation Action Server

```python
#!/usr/bin/env python3
"""
Navigation Action Server

This node demonstrates how to create an action server for long-running
navigation tasks with feedback and result reporting.
"""

import rclpy
from rclpy.action import ActionServer, CancelResponse, GoalResponse
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy

from nav2_msgs.action import NavigateToPose
from geometry_msgs.msg import PoseStamped, Pose
from std_msgs.msg import String

import time
import math
from enum import Enum
from threading import Lock


class NavigationState(Enum):
    """
    Navigation state for tracking progress.
    """
    IDLE = 0
    NAVIGATING = 1
    CANCELLED = 2
    FAILED = 3
    SUCCEEDED = 4


class NavigationActionServer(Node):
    """
    An action server that handles navigation goals with feedback.
    """

    def __init__(self):
        super().__init__('navigation_action_server')

        # QoS profile
        self.qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
            depth=10
        )

        # Action server
        self._action_server = ActionServer(
            self,
            NavigateToPose,
            'navigate_to_pose',
            execute_callback=self.execute_callback,
            goal_callback=self.goal_callback,
            cancel_callback=self.cancel_callback)

        # Publishers for status
        self.status_publisher = self.create_publisher(String, '/navigation_status', self.qos_profile)

        # Internal state
        self.current_goal = None
        self.navigation_state = NavigationState.IDLE
        self.navigation_lock = Lock()

        self.get_logger().info('Navigation Action Server initialized')

    def goal_callback(self, goal_request):
        """
        Accept or reject a goal.
        """
        self.get_logger().info('Received navigation goal request')

        # Check if current navigation can be interrupted
        if self.navigation_state == NavigationState.NAVIGATING:
            return GoalResponse.REJECT
        else:
            return GoalResponse.ACCEPT

    def cancel_callback(self, goal_handle):
        """
        Accept or reject a cancel request.
        """
        self.get_logger().info('Received cancel request')
        return CancelResponse.ACCEPT

    def execute_callback(self, goal_handle):
        """
        Execute the navigation goal with feedback.
        """
        self.get_logger().info('Executing navigation goal')

        # Update internal state
        with self.navigation_lock:
            self.current_goal = goal_handle
            self.navigation_state = NavigationState.NAVIGATING

        # Get target pose from goal
        target_pose = goal_handle.request.pose
        self.get_logger().info(f'Navigating to: ({target_pose.pose.position.x:.2f}, {target_pose.pose.position.y:.2f})')

        # Navigation feedback message
        feedback_msg = NavigateToPose.Feedback()
        feedback_msg.current_pose = PoseStamped()
        feedback_msg.current_pose.pose.position.x = 0.0
        feedback_msg.current_pose.pose.position.y = 0.0
        feedback_msg.distance_remaining = 0.0

        # Simulate navigation process
        start_time = time.time()
        total_distance = self.calculate_distance_to_target(target_pose)
        current_distance = total_distance

        try:
            while current_distance > 0   10cm tolerance
                # Check if goal was cancelled
                if goal_handle.is_cancel_requested:
                    goal_handle.canceled()
                    self.navigation_state = NavigationState.CANCELLED

                    # Publish status update
                    status_msg = String()
                    status_msg.data = 'Navigation cancelled'
                    self.status_publisher.publish(status_msg)

                    self.get_logger().info('Navigation cancelled')
                    return NavigateToPose.Result()

                # Update feedback
                feedback_msg.distance_remaining = current_distance
                feedback_msg.current_pose.pose.position.x += 0.01  # Simulate movement
                feedback_msg.current_pose.pose.position.y += 0.01  # Simulate movement

                goal_handle.publish_feedback(feedback_msg)

                # Update distance
                current_distance = self.calculate_distance_to_target(target_pose,
                    feedback_msg.current_pose.pose.position)

                # Sleep to simulate navigation time
                time.sleep(0.1)

                # Publish progress status
                status_msg = String()
                status_msg.data = f'Navigating: {current_distance:.2f}m remaining'
                self.status_publisher.publish(status_msg)

        except Exception as e:
            self.get_logger().error(f'Navigation error: {e}')
            self.navigation_state = NavigationState.FAILED

            goal_handle.abort()
            result = NavigateToPose.Result()
            result.result = False
            result.status = -1  # Failed

            # Publish status update
            status_msg = String()
            status_msg.data = f'Navigation failed: {e}'
            self.status_publisher.publish(status_msg)

            return result

        # Navigation completed successfully
        self.navigation_state = NavigationState.SUCCEEDED

        goal_handle.succeed()
        result = NavigateToPose.Result()
        result.result = True
        result.status = 1  # Succeeded

        # Publish completion status
        status_msg = String()
        status_msg.data = 'Navigation completed successfully'
        self.status_publisher.publish(status_msg)

        self.get_logger().info('Navigation completed successfully')
        return result

    def calculate_distance_to_target(self, target_pose, current_pos=None):
        """
        Calculate Euclidean distance to target.
        """
        if current_pos is None:
            current_pos = Pose()
            current_pos.position.x = 0.0
            current_pos.position.y = 0.0

        dx = target_pose.pose.position.x - current_pos.position.x
        dy = target_pose.pose.position.y - current_pos.position.y
        distance = math.sqrt(dx*dx + dy*dy)

        return distance


def main(args=None):
    """
    Main function to run the navigation action server.
    """
    rclpy.init(args=args)
    navigation_server = NavigationActionServer()

    try:
        rclpy.spin(navigation_server)
    except KeyboardInterrupt:
        pass
    finally:
        navigation_server.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

### Action Client Example: Navigation Action Client

```python
#!/usr/bin/env python3
"""
Navigation Action Client

This node demonstrates how an AI agent can use actions for long-running
navigation tasks with feedback and result reporting.
"""

import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy

from nav2_msgs.action import NavigateToPose
from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion
from std_msgs.msg import String

import time
import random


class NavigationActionClient(Node):
    """
    An AI agent that uses navigation actions for long-running tasks.
    """

    def __init__(self):
        super().__init__('navigation_action_client')

        # QoS profile
        self.qos_profile = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
            depth=10
        )

        # Action client for navigation
        self._action_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')

        # Publisher for AI decisions
        self.decision_publisher = self.create_publisher(String, '/ai_decisions', self.qos_profile)

        # Timer to periodically send navigation goals
        self.timer = self.create_timer(5.0, self.send_navigation_goals)  # Every 5 seconds
        self.goal_count = 0

        self.get_logger().info('Navigation Action Client initialized')

    def send_navigation_goals(self):
        """
        Send navigation goals to the action server.
        """
        # Wait for action server
        if not self._action_client.wait_for_server(timeout_sec=1.0):
            self.get_logger().error('Navigation action server not available')
            return

        # Create navigation goal
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()

        # Set goal position (example: move in a pattern)
        positions = [
            (1.0, 0.0),   # Right
            (1.0, 1.0),   # Up
            (0.0, 1.0),   # Left
            (0.0, 0.0),   # Back to start
        ]

        pos_idx = self.goal_count % len(positions)
        pos = positions[pos_idx]

        goal_msg.pose.pose.position.x = pos[0]
        goal_msg.pose.pose.position.y = pos[1]
        goal_msg.pose.pose.position.z = 0.0
        goal_msg.pose.pose.orientation.w = 1.0  # No rotation

        # Send goal with feedback callback
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback)

        self._send_goal_future.add_done_callback(self.goal_response_callback)

        self.get_logger().info(f'Sent navigation goal {self.goal_count + 1} to position: {pos}')
        self.goal_count += 1

    def goal_response_callback(self, future):
        """
        Handle goal response.
        """
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Navigation goal rejected')
            return

        self.get_logger().info('Navigation goal accepted')

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def feedback_callback(self, feedback_msg):
        """
        Handle feedback during navigation execution.
        """
        distance_remaining = feedback_msg.feedback.distance_remaining
        current_pos = feedback_msg.feedback.current_pose.pose.position

        self.get_logger().debug(f'Navigation in progress: {distance_remaining:.2f}m remaining at ({current_pos.x:.2f}, {current_pos.y:.2f})')

        # AI can make decisions based on feedback
        if distance_remaining < 0.5:
            # Approaching destination - AI might prepare for next action
            decision_msg = String()
            decision_msg.data = f'Approaching destination, distance: {distance_remaining:.2f}m'
            self.decision_publisher.publish(decision_msg)

    def get_result_callback(self, future):
        """
        Handle navigation result.
        """
        result = future.result().result
        if result.result:
            self.get_logger().info('Navigation completed successfully')

            # AI can make decisions based on successful navigation
            decision_msg = String()
            decision_msg.data = f'Navigation completed, at position: ({result.current_pose.pose.position.x:.2f}, {result.current_pose.pose.position.y:.2f})'
            self.decision_publisher.publish(decision_msg)
        else:
            self.get_logger().error('Navigation failed')

            # AI can handle navigation failure
            decision_msg = String()
            decision_msg.data = 'Navigation failed, need to replan'
            self.decision_publisher.publish(decision_msg)


def main(args=None):
    """
    Main function to run the navigation action client.
    """
    rclpy.init(args=args)
    nav_client = NavigationActionClient()

    try:
        rclpy.spin(nav_client)
    except KeyboardInterrupt:
        pass
    finally:
        nav_client.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Pattern 4: Advanced Message Filtering and Processing

### Message Filter Node: AI Sensor Data Processor

```python
#!/usr/bin/env python3
"""
AI Sensor Data Processor

This node demonstrates advanced message filtering and processing
techniques for AI agents working with sensor data.
"""

import rclpy
from rclpy.node import Node
from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy

from sensor_msgs.msg import LaserScan, Image, PointCloud2
from geometry_msgs.msg import Twist
from std_msgs.msg import Float32, String
from cv_bridge import CvBridge
import cv2
import numpy as np
from collections import deque
import statistics


class AIDataProcessor(Node):
    """
    Processes and filters sensor data for AI consumption.
    """

    def __init__(self):
        super().__init__('ai_data_processor')

        # QoS profiles for different data types
        self.qos_sensor = QoSProfile(
            reliability=ReliabilityPolicy.BEST_EFFORT,
            durability=DurabilityPolicy.VOLATILE,
            depth=10
        )

        self.qos_command = QoSProfile(
            reliability=ReliabilityPolicy.RELIABLE,
            durability=DurabilityPolicy.VOLATILE,
            depth=10
        )

        # Subscribers
        self.laser_subscriber = self.create_subscription(
            LaserScan, '/scan', self.laser_callback, self.qos_sensor)
        self.image_subscriber = self.create_subscription(
            Image, '/camera/image_raw', self.image_callback, self.qos_sensor)

        # Publishers
        self.processed_laser_publisher = self.create_publisher(
            LaserScan, '/processed_scan', self.qos_sensor)
        self.processed_image_publisher = self.create_publisher(
            Image, '/processed_image', self.qos_sensor)
        self.ai_commands_publisher = self.create_publisher(
            String, '/ai_commands', self.qos_command)

        # CV bridge for image processing
        self.cv_bridge = CvBridge()

        # Data buffers for filtering
        self.laser_buffer = deque(maxlen=5)  # Keep last 5 laser scans for filtering
        self.image_buffer = deque(maxlen=3)  # Keep last 3 images for temporal filtering

        # Processing parameters
        self.obstacle_threshold = 1.0  # meters
        self.motion_threshold = 50     # pixels for motion detection

        # Timer for periodic processing
        self.processing_timer = self.create_timer(0.1, self.periodic_processing)

        self.get_logger().info('AI Data Processor initialized')

    def laser_callback(self, msg):
        """
        Process incoming laser scan data.
        """
        # Add to buffer for filtering
        self.laser_buffer.append(msg)

        # Apply noise filtering
        filtered_msg = self.filter_laser_data(msg)

        # Publish processed data
        self.processed_laser_publisher.publish(filtered_msg)

    def image_callback(self, msg):
        """
        Process incoming image data.
        """
        # Add to buffer
        self.image_buffer.append(msg)

        # Process image
        try:
            cv_image = self.cv_bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')
            processed_cv_image = self.process_image_data(cv_image)

            # Convert back to ROS message
            processed_msg = self.cv_bridge.cv2_to_imgmsg(processed_cv_image, encoding='bgr8')
            processed_msg.header = msg.header

            # Publish processed image
            self.processed_image_publisher.publish(processed_msg)

        except Exception as e:
            self.get_logger().error(f'Error processing image: {e}')

    def filter_laser_data(self, msg):
        """
        Apply filtering to laser scan data.
        """
        # Create a copy of the message
        filtered_msg = LaserScan()
        filtered_msg.header = msg.header
        filtered_msg.angle_min = msg.angle_min
        filtered_msg.angle_max = msg.angle_max
        filtered_msg.angle_increment = msg.angle_increment
        filtered_msg.time_increment = msg.time_increment
        filtered_msg.scan_time = msg.scan_time
        filtered_msg.range_min = msg.range_min
        filtered_msg.range_max = msg.range_max

        # Apply median filtering to reduce noise
        ranges = list(msg.ranges)
        filtered_ranges = []

        for i in range(len(ranges)):
            # Get neighboring values for median calculation
            neighbors = []
            for j in range(max(0, i-2), min(len(ranges), i+3)):
                if 0 <= ranges[j] <= msg.range_max:  # Valid range
                    neighbors.append(ranges[j])

            if neighbors:
                median_val = statistics.median(neighbors)
                filtered_ranges.append(median_val)
            else:
                filtered_ranges.append(ranges[i])  # Keep original if no valid neighbors

        filtered_msg.ranges = filtered_ranges

        return filtered_msg

    def process_image_data(self, cv_image):
        """
        Process image data for AI consumption.
        """
        # Convert to grayscale
        gray = cv2.cvtColor(cv_image, cv2.COLOR_BGR2GRAY)

        # Apply Gaussian blur to reduce noise
        blurred = cv2.GaussianBlur(gray, (5, 5), 0)

        # Apply threshold to highlight obstacles
        _, thresholded = cv2.threshold(blurred, 50, 255, cv2.THRESH_BINARY)

        # Apply morphological operations to clean up the image
        kernel = np.ones((3,3), np.uint8)
        cleaned = cv2.morphologyEx(thresholded, cv2.MORPH_CLOSE, kernel)
        cleaned = cv2.morphologyEx(cleaned, cv2.MORPH_OPEN, kernel)

        # Convert back to color for visualization
        processed_image = cv2.cvtColor(cleaned, cv2.COLOR_GRAY2BGR)

        return processed_image

    def periodic_processing(self):
        """
        Perform periodic processing and analysis.
        """
        # Analyze laser data for obstacles
        if self.laser_buffer:
            latest_scan = self.laser_buffer[-1]
            obstacles_detected = self.analyze_obstacles(latest_scan)

            if obstacles_detected:
                # Send AI command for obstacle avoidance
                cmd_msg = String()
                cmd_msg.data = f'OBSTACLE_DETECTED_{len(obstacles_detected)}_obstacles'
                self.ai_commands_publisher.publish(cmd_msg)

    def analyze_obstacles(self, scan_msg):
        """
        Analyze laser scan for obstacles.
        """
        obstacles = []
        threshold = self.obstacle_threshold

        for i, range_val in enumerate(scan_msg.ranges):
            if 0.1 < range_val < threshold:  # Valid range within threshold
                angle = scan_msg.angle_min + i * scan_msg.angle_increment
                obstacles.append({
                    'range': range_val,
                    'angle': angle,
                    'index': i
                })

        return obstacles


def main(args=None):
    """
    Main function to run the AI data processor.
    """
    rclpy.init(args=args)
    data_processor = AIDataProcessor()

    try:
        rclpy.spin(data_processor)
    except KeyboardInterrupt:
        pass
    finally:
        data_processor.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```

## Best Practices for Message Passing

### 1. QoS Configuration Guidelines

```python
# QoS configuration examples for different scenarios

# For critical commands (velocity, emergency stop)
critical_qos = QoSProfile(
    reliability=ReliabilityPolicy.RELIABLE,
    durability=DurabilityPolicy.VOLATILE,
    history=HistoryPolicy.KEEP_LAST,
    depth=10
)

# For sensor data (laser, camera, IMU)
sensor_qos = QoSProfile(
    reliability=ReliabilityPolicy.BEST_EFFORT,
    durability=DurabilityPolicy.VOLATILE,
    history=HistoryPolicy.KEEP_LAST,
    depth=5
)

# For logging and debugging
debug_qos = QoSProfile(
    reliability=ReliabilityPolicy.BEST_EFFORT,
    durability=DurabilityPolicy.VOLATILE,
    history=HistoryPolicy.KEEP_ALL,
    depth=100
)
```

### 2. Error Handling Patterns

```python
def robust_command_publisher(self, command):
    """
    Robust command publishing with error handling.
    """
    try:
        # Validate command before publishing
        if not self.validate_command(command):
            self.get_logger().error('Invalid command rejected')
            return False

        # Publish command
        self.command_publisher.publish(command)
        return True

    except Exception as e:
        self.get_logger().error(f'Error publishing command: {e}')
        return False

def validate_command(self, command):
    """
    Validate command before execution.
    """
    # Example validation checks
    if hasattr(command, 'linear') and hasattr(command, 'angular'):
        # Check velocity limits
        if abs(command.linear.x) > 1.0 or abs(command.angular.z) > 1.0:
            return False
    return True
```

## Summary

This section demonstrates various message passing patterns:

1. **Topic-based communication**: For continuous, asynchronous data flow
2. **Service-based communication**: For synchronous request/response interactions
3. **Action-based communication**: For long-running tasks with feedback
4. **Advanced filtering**: For processing sensor data for AI consumption

Each pattern serves different purposes in AI-ROS integration, and understanding when to use each is crucial for building robust systems.

### Cross-References to Related Sections

For deeper understanding of related concepts, see:
- [How Python AI Agents Send Commands to ROS 2 Controllers](./ai-ros-integration) - Command sending patterns
- [How Python AI Agents Receive Sensor Data](./message-passing) - Data receiving patterns
- [Data Flow Diagrams](./data-flow-diagrams) - Communication architecture
- [Practical Examples](./practical-examples) - Complete system implementations
- [ROS 2 Architecture Understanding](../chapter-1/intro) - Communication patterns foundation