---
sidebar_position: 7
title: 'Simulation-Based Execution Instructions'
keywords: [ros2, python, simulation, execution, tutorial, no-hardware, gazebo, isaac, unity]
description: 'Instructions for running ROS 2 nodes in simulation environments without physical hardware'
---

# Simulation-Based Execution Instructions

## Learning Objectives

After completing this section, you will be able to:
- Set up and run ROS 2 nodes in simulation environments
- Use Gazebo, Isaac Sim, or other simulation tools with ROS 2
- Configure simulation environments for testing ROS 2 nodes
- Execute ROS 2 nodes without requiring physical hardware
- Understand the benefits and limitations of simulation-based development

## Introduction to Simulation-Based Development

Simulation is a critical component of robotics development that allows you to:
- Test and validate ROS 2 nodes without physical hardware
- Develop and debug code in a safe, controlled environment
- Experiment with different scenarios without risk of damage
- Accelerate development cycles through rapid iteration

Simulation environments provide virtual representations of:
- Robot hardware and sensors
- Physical environments and physics
- Sensor data and feedback
- Interaction with objects and obstacles

## Setting Up Your Simulation Environment

### Prerequisites

Before running ROS 2 nodes in simulation, ensure you have:

1. **ROS 2 Installation**: A working ROS 2 installation (e.g., Humble Hawksbill)
2. **Simulation Software**: Install one of the following simulation environments:
   - Gazebo Garden or Fortress
   - NVIDIA Isaac Sim (for advanced GPU-accelerated simulation)
   - Webots
   - Unity Robotics Simulation (with ROS# plugin)

3. **ROS 2 Simulation Packages**:
   ```bash
   # For Gazebo
   sudo apt install ros-humble-gazebo-ros-pkgs
   sudo apt install ros-humble-gazebo-ros2-control
   sudo apt install ros-humble-gazebo-dev

   # For other simulation environments, install appropriate ROS 2 packages
   ```

### Installing Gazebo (Recommended for Beginners)

Gazebo is the most commonly used simulation environment for ROS 2. Here's how to install it:

```bash
# Update package list
sudo apt update

# Install Gazebo Garden (recommended version for ROS 2 Humble)
sudo apt install gazebo-garden

# Install ROS 2 Gazebo integration packages
sudo apt install ros-humble-gazebo-ros-pkgs ros-humble-gazebo-ros2-control
```

## Basic Simulation Workflow

### Step 1: Launch the Simulation Environment

```bash
# Launch Gazebo with an empty world
gz sim -r empty.sdf

# Or launch with a specific world file
gz sim -r my_world.sdf
```

### Step 2: Spawn Your Robot Model

For this example, we'll use a simple differential drive robot model. First, create a URDF file for your robot:

**my_robot.urdf**:
```xml
<?xml version="1.0"?>
<robot name="my_robot">
  <!-- Base Link -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="0.5 0.3 0.15"/>
      </geometry>
      <material name="blue">
        <color rgba="0 0 1 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <box size="0.5 0.3 0.15"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="1.0"/>
      <inertia ixx="0.1" ixy="0" ixz="0" iyy="0.1" iyz="0" izz="0.1"/>
    </inertial>
  </link>

  <!-- Left Wheel -->
  <link name="left_wheel">
    <visual>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
      <material name="black">
        <color rgba="0 0 0 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.1"/>
      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>
    </inertial>
  </link>

  <!-- Right Wheel -->
  <link name="right_wheel">
    <visual>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
      <material name="black">
        <color rgba="0 0 0 1"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <cylinder radius="0.1" length="0.05"/>
      </geometry>
    </collision>
    <inertial>
      <mass value="0.1"/>
      <inertia ixx="0.001" ixy="0" ixz="0" iyy="0.001" iyz="0" izz="0.001"/>
    </inertial>
  </link>

  <!-- Joints -->
  <joint name="left_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="left_wheel"/>
    <origin xyz="0 0.2 0" rpy="1.5708 0 0"/>
    <axis xyz="0 0 1"/>
  </joint>

  <joint name="right_wheel_joint" type="continuous">
    <parent link="base_link"/>
    <child link="right_wheel"/>
    <origin xyz="0 -0.2 0" rpy="1.5708 0 0"/>
    <axis xyz="0 0 1"/>
  </joint>
</robot>
```

### Step 3: Create a Robot State Publisher Node

Create a simple Python node to publish the robot state:

**robot_state_publisher.py**:
```python
#!/usr/bin/env python3
"""
Robot State Publisher for Simulation

This node publishes the robot's joint states for visualization in simulation.
"""

import rclpy
from rclpy.node import Node
from sensor_msgs.msg import JointState
from geometry_msgs.msg import TransformStamped
import math

class RobotStatePublisher(Node):
    def __init__(self):
        super().__init__('robot_state_publisher')

        # Publisher for joint states
        self.joint_pub = self.create_publisher(JointState, 'joint_states', 10)

        # Timer for publishing joint states
        self.timer = self.create_timer(0.1, self.publish_joint_states)

        # Initial joint positions
        self.left_wheel_pos = 0.0
        self.right_wheel_pos = 0.0

        self.get_logger().info('Robot State Publisher initialized')

    def publish_joint_states(self):
        # Create joint state message
        msg = JointState()
        msg.name = ['left_wheel_joint', 'right_wheel_joint']
        msg.position = [self.left_wheel_pos, self.right_wheel_pos]
        msg.velocity = [0.0, 0.0]
        msg.effort = [0.0, 0.0]

        # Set timestamp
        msg.header.stamp = self.get_clock().now().to_msg()
        msg.header.frame_id = 'base_link'

        # Publish the message
        self.joint_pub.publish(msg)

def main(args=None):
    rclpy.init(args=args)
    node = RobotStatePublisher()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Running ROS 2 Nodes in Gazebo Simulation

### Method 1: Using ROS 2 Control with Gazebo

1. **Create a ROS 2 Control configuration file**:

**my_robot_control.yaml**:
```yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz

    joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster

    diff_drive_controller:
      type: diff_drive_controller/DiffDriveController

diff_drive_controller:
  ros__parameters:
    left_wheel_names: ["left_wheel_joint"]
    right_wheel_names: ["right_wheel_joint"]

    wheel_separation: 0.4
    wheel_radius: 0.1

    publish_rate: 50.0
    odom_frame_id: odom
    base_frame_id: base_link
    pose_covariance_diagonal: [0.001, 0.001, 0.001, 0.001, 0.001, 0.01]
    twist_covariance_diagonal: [0.001, 0.001, 0.001, 0.001, 0.001, 0.01]
```

2. **Launch the robot in simulation**:

Create a launch file **launch/my_robot_simulation.py**:
```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node
from launch.actions import IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    # Get the launch directory
    pkg_gazebo_ros = get_package_share_directory('gazebo_ros')
    pkg_my_robot = get_package_share_directory('my_robot')

    # Declare launch arguments
    world = LaunchConfiguration('world')
    world_arg = DeclareLaunchArgument(
        'world',
        default_value=os.path.join(pkg_my_robot, 'worlds', 'empty.sdf'),
        description='SDF world file')

    # Launch Gazebo
    gazebo = IncludeLaunchDescription(
        PythonLaunchDescriptionSource(
            os.path.join(pkg_gazebo_ros, 'launch', 'gz_sim.launch.py')),
        launch_arguments={'gz_args': '-r empty.sdf'}.items(),
    )

    # Spawn the robot in Gazebo
    spawn_entity = Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=['-topic', 'robot_description',
                   '-entity', 'my_robot'],
        output='screen'
    )

    # Robot State Publisher
    robot_state_publisher = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        parameters=[{'use_sim_time': True}],
        output='screen'
    )

    # Controller Manager
    controller_manager = Node(
        package='controller_manager',
        executable='ros2_control_node',
        parameters=[os.path.join(pkg_my_robot, 'config', 'my_robot_control.yaml')],
        output='screen'
    )

    return LaunchDescription([
        world_arg,
        gazebo,
        spawn_entity,
        robot_state_publisher,
        controller_manager,
    ])
```

3. **Run the simulation**:

```bash
# Terminal 1: Launch the simulation
ros2 launch my_robot my_robot_simulation.py

# Terminal 2: Run your custom ROS 2 nodes
python3 my_publisher_node.py

# Terminal 3: Run subscriber nodes or other components
python3 my_subscriber_node.py
```

### Method 2: Simple Simulation with Velocity Commands

For simpler testing without complex robot models, you can use the `turtlebot3` simulation which is widely available:

1. **Install TurtleBot3 simulation packages**:
```bash
sudo apt install ros-humble-turtlebot3 ros-humble-turtlebot3-gazebo
```

2. **Set environment variables**:
```bash
export TURTLEBOT3_MODEL=burger
```

3. **Launch the simulation**:
```bash
# Terminal 1: Launch Gazebo with TurtleBot3
ros2 launch turtlebot3_gazebo empty_world.launch.py

# Terminal 2: Run your custom nodes that send velocity commands
python3 my_velocity_publisher.py
```

## Testing Your Nodes in Simulation

### Example: Testing a Simple Publisher Node

Create a test publisher that sends velocity commands to your simulated robot:

**test_velocity_publisher.py**:
```python
#!/usr/bin/env python3
"""
Test Velocity Publisher for Simulation

This node sends simple velocity commands to test robot movement in simulation.
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist

class TestVelocityPublisher(Node):
    def __init__(self):
        super().__init__('test_velocity_publisher')

        # Publisher for velocity commands
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)

        # Timer to send commands periodically
        self.timer = self.create_timer(0.5, self.send_velocity_command)

        # Counter to change movement pattern
        self.counter = 0

        self.get_logger().info('Test Velocity Publisher initialized')

    def send_velocity_command(self):
        msg = Twist()

        # Simple movement pattern: forward, turn, forward, stop
        if self.counter < 10:  # Move forward for 5 seconds
            msg.linear.x = 0.5  # 0.5 m/s forward
            msg.angular.z = 0.0  # No rotation
        elif self.counter < 20:  # Turn for 5 seconds
            msg.linear.x = 0.0   # No forward movement
            msg.angular.z = 0.5  # 0.5 rad/s rotation
        elif self.counter < 30:  # Move forward again
            msg.linear.x = 0.5   # 0.5 m/s forward
            msg.angular.z = 0.0  # No rotation
        else:  # Stop and reset
            msg.linear.x = 0.0
            msg.angular.z = 0.0
            self.counter = -1  # Reset to -1 so it becomes 0 on next increment

        self.cmd_vel_pub.publish(msg)
        self.counter += 1

        self.get_logger().info(f'Sent velocity command: linear={msg.linear.x}, angular={msg.angular.z}')

def main(args=None):
    rclpy.init(args=args)
    node = TestVelocityPublisher()

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

### Running the Test

```bash
# Terminal 1: Launch simulation
export TURTLEBOT3_MODEL=burger
ros2 launch turtlebot3_gazebo empty_world.launch.py

# Terminal 2: Run your test publisher
python3 test_velocity_publisher.py

# Terminal 3: Monitor the robot's position (optional)
ros2 topic echo /odom
```

## Alternative Simulation Environments

### NVIDIA Isaac Sim

For more advanced simulation with realistic physics and rendering:

1. **Install Isaac Sim** from NVIDIA's website
2. **Install ROS 2 Bridge**:
```bash
git clone https://github.com/NVIDIA-Omniverse/Isaac_ROS_Bridges.git
cd Isaac_ROS_Bridges
./scripts/build.sh
```

3. **Run with Isaac Sim**:
```bash
# Launch Isaac Sim with ROS 2 bridge
./isaac-sim/python.sh -m Isaac_ROS_Bridges.launch
```

### Webots

For a cross-platform simulation environment:

1. **Install Webots**:
```bash
sudo apt install webots
```

2. **Install ROS 2 interface**:
```bash
sudo apt install ros-humble-webots-ros2
```

3. **Run with Webots**:
```bash
ros2 launch webots_ros2_universal_robot robot_launch.py
```

## Best Practices for Simulation-Based Development

### 1. Use Simulation Parameters
Create launch files that can switch between simulation and real hardware:

```python
# In your launch file
use_sim_time_arg = DeclareLaunchArgument(
    'use_sim_time',
    default_value='true',
    description='Use simulation (Gazebo) clock if true')

# Pass to nodes
Node(
    package='my_package',
    executable='my_node',
    parameters=[{'use_sim_time': LaunchConfiguration('use_sim_time')}],
)
```

### 2. Validate Sensor Data
Ensure your nodes can handle the sensor data from simulation:

```python
def sensor_callback(self, msg):
    # Validate data ranges are reasonable
    if not self.validate_sensor_data(msg):
        self.get_logger().warn('Invalid sensor data received')
        return

    # Process valid data
    self.process_sensor_data(msg)
```

### 3. Test Edge Cases
Use simulation to test scenarios that would be difficult or dangerous with real hardware:
- Obstacle avoidance
- Emergency stops
- Sensor failures
- Extreme conditions

### 4. Performance Monitoring
Monitor performance in simulation to ensure your nodes will work in real-time:

```python
import time

def process_callback(self, msg):
    start_time = time.time()

    # Process the message
    self.process_data(msg)

    # Log processing time
    processing_time = time.time() - start_time
    if processing_time > 0.1:  # 100ms threshold
        self.get_logger().warn(f'Processing took {processing_time:.3f}s')
```

## Troubleshooting Common Simulation Issues

### Issue 1: Nodes Don't Connect to Simulation
**Symptom**: Nodes can't communicate with the simulation
**Solution**: Ensure both simulation and nodes use the same ROS domain ID:
```bash
export ROS_DOMAIN_ID=0
# Run both simulation and nodes in the same terminal or with the same domain ID
```

### Issue 2: Robot Doesn't Respond to Commands
**Symptom**: Velocity commands are published but robot doesn't move
**Solution**: Check topic names and ensure controllers are running:
```bash
# Check if the topic exists and is being published to
ros2 topic list | grep cmd_vel

# Check if controllers are loaded
ros2 control list_controllers
```

### Issue 3: High CPU Usage
**Symptom**: Simulation runs slowly or computer becomes unresponsive
**Solution**: Reduce simulation update rate or use simpler models:
```bash
# In your Gazebo world file, reduce physics update rate
<physics type="ode">
  <max_step_size>0.01</max_step_size>  <!-- Increase this value -->
  <real_time_factor>0.5</real_time_factor>  <!-- Reduce this value -->
</physics>
```

## Summary

Simulation-based execution allows you to develop and test ROS 2 nodes without physical hardware. Key points include:

1. **Setting up the simulation environment** with appropriate software and packages
2. **Creating launch files** to coordinate simulation and node execution
3. **Testing nodes** in a safe, repeatable environment
4. **Validating functionality** before deployment to real hardware
5. **Following best practices** for effective simulation-based development

Simulation is an invaluable tool for robotics development, allowing for rapid iteration and safe testing of complex robotic behaviors.

### Cross-References to Related Sections

For deeper understanding of related concepts, see:
- [Introduction to Python ROS 2 Nodes](./intro) - Overview of Python ROS 2 development
- [Creating a Python Publisher Node](./publisher-node) - Creating nodes for simulation
- [Creating a Python Subscriber Node](./subscriber-node) - Receiving data from simulation
- [ROS 2 Topics](../chapter-1/topics) - Understanding communication in simulation
- [URDF Understanding](../chapter-4/intro) - Creating robot models for simulation